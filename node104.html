<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--Converted with LaTeX2HTML 97.1 (release) (July 13th, 1997)
 by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippman, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>FileStat.h</TITLE>
<META NAME="description" CONTENT="FileStat.h">
<META NAME="keywords" CONTENT="oops">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
<LINK REL="STYLESHEET" HREF="oops.css">
<LINK REL="next" HREF="node105.html">
<LINK REL="previous" HREF="node103.html">
<LINK REL="up" HREF="node99.html">
<LINK REL="next" HREF="node105.html">
</HEAD>
<BODY BGCOLOR=#FFFFF0>
<!--Navigation Panel-->
<A NAME="tex2html1627"
 HREF="node105.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1623"
 HREF="node99.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1617"
 HREF="node103.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html1625"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html1626"
 HREF="node107.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html1628"
 HREF="node105.html">Main.cc</A>
<B> Up:</B> <A NAME="tex2html1624"
 HREF="node99.html">The Sources</A>
<B> Previous:</B> <A NAME="tex2html1618"
 HREF="node103.html">SortedTable.h</A>
<BR>
<BR>
<!--End of Navigation Panel-->
<H1><A NAME="SECTION001150000000000000000">
<TT>FileStat.h</TT></A>
</H1>

<PRE>
// FileStat.h
// 12/16/97

#ifndef __FILE_STAT_H__
#define __FILE_STAT_H__
#pragma interface &quot;FileStat.h&quot;

#ifndef __BASIC_TYPES__
#define __BASIC_TYPES__
typedef int Integer32;
typedef Integer32 SizeType;
typedef Integer32 OffsetType;
typedef Integer32 CounterType;
typedef Integer32 ArenaID;
typedef Integer32 EntryID;
typedef Integer32 BoolType;
enum { True = 1, False = 0 };
typedef Integer32 ComparisonType;
enum { GreaterThan = 1, EqualTo = 0, LessThan = -1 };
typedef void *PointerType;

#endif // __BASIC_TYPES__

#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;dirent.h&gt;
#include &lt;Regex.h&gt;
#include &lt;stdlib.h&gt;

// Wrapper class for stat() system call
class FileStat {
protected:
  char *path;
  enum FileStatus {
    Found, NotFound
  } status;
  struct stat st;
  uid_t uid;
  gid_t gid;
public:
  FileStat(const char *p = 0) {
    if (p == 0) {
      path = 0;
      status = NotFound;
      return;
    }
    path = new char[strlen(p) + 1];
    strcpy(path, p);
    if (stat(path, &amp;st) != 0) {
      status = NotFound;
      return;
    } else {
      status = Found;
      uid = geteuid();
      gid = getegid();
    }
  }
  ~FileStat() {
    if (path) 
      delete path;
  }
  BoolType restat() {
    if (path == 0 || stat(path, &amp;st) != 0) {
      status = NotFound;
      return False;
    } else {
      status = Found;
      return True;
    }
  }
  inline BoolType exists() {
    return status == Found;
  }
  inline BoolType isRegularFile() {
    return status == Found &amp;&amp; S_ISREG(st.st_mode);
  }
  inline BoolType isDirectory() {
    return status == Found &amp;&amp; S_ISDIR(st.st_mode);
  }
  inline BoolType isCharacterDevice() {
    return status == Found &amp;&amp; S_ISCHR(st.st_mode);
  }
  inline BoolType isBlockDevice() {
    return status == Found &amp;&amp; S_ISBLK(st.st_mode);
  }  
  inline BoolType isFIFO() {
    return status == Found &amp;&amp; S_ISFIFO(st.st_mode);
  }  
  inline BoolType isSocket() {
    return status == Found &amp;&amp; S_ISSOCK(st.st_mode);
  }  
  inline BoolType isLink() {
    return status == Found &amp;&amp; S_ISLNK(st.st_mode);
  }  
  inline SizeType getSize() {
    return status == Found ? (SizeType)st.st_size : 0;
  }
  BoolType isReadable() {
    if (status == NotFound)
      return False;
    if (uid == st.st_uid) {
      return (st.st_mode &amp; S_IRUSR) == S_IRUSR;
    } else if (gid == st.st_gid) {
      return (st.st_mode &amp; S_IRGRP) == S_IRGRP;
    } else {
      return (st.st_mode &amp; S_IROTH) == S_IROTH;
    }
  }
  BoolType isWritable() {
    if (status == NotFound)
      return False;
    if (uid == st.st_uid) {
      return (st.st_mode &amp; S_IWUSR) == S_IWUSR;
    } else if (gid == st.st_gid) {
      return (st.st_mode &amp; S_IWGRP) == S_IWGRP;
    } else {
      return (st.st_mode &amp; S_IWOTH) == S_IWOTH;
    }
  }
  BoolType isExecutable() {
    if (status == NotFound)
      return False;
    if (uid == st.st_uid) {
      return (st.st_mode &amp; S_IXUSR) == S_IXUSR;
    } else if (gid == st.st_gid) {
      return (st.st_mode &amp; S_IXGRP) == S_IXGRP;
    } else {
      return (st.st_mode &amp; S_IXOTH) == S_IXOTH;
    }
  }
};

// Wrapper class for scandir() systemcall
// Regular expression is used for wildcard
class ScanDir : public FileStat {
protected:
  SizeType number;
  SizeType index;
  SizeType entry;
  struct dirent **namelist;
  Regex wildcard;
public:
  ScanDir(const char *p, const char *w) : 
    FileStat(p), entry(-1), wildcard(w ? w : &quot;[^\\.].*&quot;) {
    if (isDirectory() &amp;&amp; isReadable() &amp;&amp; isExecutable()) {
      number = scandir(p, &amp;namelist, 0, alphasort);
    } else {
      number = -1;
      namelist = 0;
    }
  }
  ~ScanDir() {
    if (namelist != 0) {
      for (index = 0; index &lt; number; index++) {
        free(namelist[index]);
      }
      free(namelist);
    }
  }
  SizeType entries() {
    if (entry &lt; 0) {
      int i = index;
      initFilter();
      for (entry = 0; getNextEntry() != 0; entry++)
        ;
      index = i;
    } 
    return entry;
  }
  BoolType initFilter() {
    index = 0;
    return number &gt;= 0 ? True : False;
  }
  const char *getNextEntry() {
    if (index &lt; 0 || number &lt;= 0 || index &gt;= number) return 0;
    struct dirent *ent;
    for (ent = 0; index &lt; number; index++) {
      ent = namelist[index];
      int len = strlen(ent-&gt;d_name);
      if (wildcard.match(ent-&gt;d_name, len) == len) 
        break;
    }
    if (index &lt; number) {
      index++;
      return ent-&gt;d_name;
    } else {
      return 0;
    }
  }
};

// Wrapper class for low level file I/O
class RawFile : public FileStat {
protected:
  int fileDesc;
public:
  RawFile(const char *file) : FileStat(file) { fileDesc = -1; }
  RawFile(int fd = 0, const char *file = 0): FileStat(file), fileDesc(fd) {}
  inline int getFileDesc() {
    return fileDesc;
  }
  int open(int flags = O_RDWR, mode_t mode = S_IRUSR | S_IWUSR) {
    if (exists() &amp;&amp; !isDirectory()) {
      fileDesc = ::open(path, flags, mode);
      restat();
      return fileDesc;
    } else {
      return -1;
    }
  }
  int create(mode_t mode = S_IRUSR | S_IWUSR) {
    fileDesc = ::creat(path, mode);
    restat();
    return fileDesc;
  }
  int close() {
    if (fileDesc &gt;= 0) {
      int retcode = ::close(fileDesc);
      restat();
      fileDesc = -1;
      return retcode;
    } else {
      return -1;
    }
  }
  SizeType read(void *buf, SizeType count) {
    if (fileDesc &gt;= 0 &amp;&amp; buf != 0 &amp;&amp; count &gt;= 0) {
      count = ::read(fileDesc, buf, count);
      restat();
      return count;
    } else {
      return -1;
    }
  }
  SizeType write(const void *buf, SizeType count) {
    if (fileDesc &gt;= 0 &amp;&amp; buf != 0 &amp;&amp; count &gt;= 0) {
      count = ::write(fileDesc, buf, count);
      restat();
      return count;
    } else {
      return -1;
    }
  }
  OffsetType seek(OffsetType off = 0, int whence = SEEK_SET) {
    if (fileDesc &gt;= 0) {
      off = ::lseek(fileDesc, off, whence);
      restat();
      return off;
    } else {
      return -1;
    }
  }
};

#endif // __FILE_STAT_H__
</PRE>

<P>
<BR><HR>
<ADDRESS>
Mori Tetsuya / t2y3141592@gmail.com
</ADDRESS>
</BODY>
</HTML>
